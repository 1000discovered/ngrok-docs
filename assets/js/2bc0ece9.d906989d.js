"use strict";(self.webpackChunkngrok_doc=self.webpackChunkngrok_doc||[]).push([[89338],{4673:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>m});var n=a(51163),r=(a(59496),a(49613));const l={title:"Event Source Reference"},i="Event Source Reference",d={unversionedId:"events/reference",id:"events/reference",title:"Event Source Reference",description:"---",source:"@site/docs/events/reference.mdx",sourceDirName:"events",slug:"/events/reference",permalink:"/docs/events/reference",draft:!1,editUrl:"https://github.com/ngrok/ngrok-docs/edit/main/docs/events/reference.mdx",tags:[],version:"current",lastUpdatedBy:"Russ Savage",lastUpdatedAt:1691862991,formattedLastUpdatedAt:"Aug 12, 2023",frontMatter:{title:"Event Source Reference"},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/events/"},next:{title:"Overview",permalink:"/docs/api/"}},p={},m=[{value:"Event Sources",id:"event-sources",level:2},{value:"Traffic Events",id:"traffic-events",level:4},{value:"Configuration Events",id:"configuration-events",level:4},{value:"Traffic Events",id:"traffic-events-1",level:2},{value:"HTTP Request Complete",id:"http-request-complete",level:3},{value:"http_request_complete.v0",id:"http_request_completev0",level:4},{value:"TCP Connection Closed",id:"tcp-connection-closed",level:3},{value:"tcp_connection_closed.v0",id:"tcp_connection_closedv0",level:4},{value:"Configuration Events",id:"configuration-events-1",level:2},{value:"API Key",id:"api-key",level:3},{value:"api_key_created.v0",id:"api_key_createdv0",level:4},{value:"api_key_deleted.v0",id:"api_key_deletedv0",level:4},{value:"api_key_updated.v0",id:"api_key_updatedv0",level:4},{value:"Certificate Authority",id:"certificate-authority",level:3},{value:"certificate_authority_created.v0",id:"certificate_authority_createdv0",level:4},{value:"certificate_authority_deleted.v0",id:"certificate_authority_deletedv0",level:4},{value:"certificate_authority_updated.v0",id:"certificate_authority_updatedv0",level:4},{value:"Domain",id:"domain",level:3},{value:"domain_created.v0",id:"domain_createdv0",level:4},{value:"domain_deleted.v0",id:"domain_deletedv0",level:4},{value:"domain_updated.v0",id:"domain_updatedv0",level:4},{value:"Event Destination",id:"event-destination",level:3},{value:"event_destination_created.v0",id:"event_destination_createdv0",level:4},{value:"event_destination_deleted.v0",id:"event_destination_deletedv0",level:4},{value:"event_destination_updated.v0",id:"event_destination_updatedv0",level:4},{value:"Event Subscription",id:"event-subscription",level:3},{value:"event_subscription_created.v0",id:"event_subscription_createdv0",level:4},{value:"event_subscription_deleted.v0",id:"event_subscription_deletedv0",level:4},{value:"event_subscription_updated.v0",id:"event_subscription_updatedv0",level:4},{value:"IP Policy",id:"ip-policy",level:3},{value:"ip_policy_created.v0",id:"ip_policy_createdv0",level:4},{value:"ip_policy_updated.v0",id:"ip_policy_updatedv0",level:4},{value:"ip_policy_deleted.v0",id:"ip_policy_deletedv0",level:4},{value:"IP Policy Rule",id:"ip-policy-rule",level:3},{value:"ip_policy_rule_created.v0",id:"ip_policy_rule_createdv0",level:4},{value:"ip_policy_rule_deleted.v0",id:"ip_policy_rule_deletedv0",level:4},{value:"ip_policy_rule_updated.v0",id:"ip_policy_rule_updatedv0",level:4},{value:"IP Restriction",id:"ip-restriction",level:3},{value:"ip_restriction_created.v0",id:"ip_restriction_createdv0",level:4},{value:"ip_restriction_deleted.v0",id:"ip_restriction_deletedv0",level:4},{value:"ip_restriction_updated.v0",id:"ip_restriction_updatedv0",level:4},{value:"SSH Certificate Authority",id:"ssh-certificate-authority",level:3},{value:"ssh_certificate_authority_created.v0",id:"ssh_certificate_authority_createdv0",level:4},{value:"ssh_certificate_authority_deleted.v0",id:"ssh_certificate_authority_deletedv0",level:4},{value:"ssh_certificate_authority_updated.v0",id:"ssh_certificate_authority_updatedv0",level:4},{value:"SSH Host Certificate",id:"ssh-host-certificate",level:3},{value:"ssh_host_certificate_created.v0",id:"ssh_host_certificate_createdv0",level:4},{value:"ssh_host_certificate_deleted.v0",id:"ssh_host_certificate_deletedv0",level:4},{value:"ssh_host_certificate_updated.v0",id:"ssh_host_certificate_updatedv0",level:4},{value:"SSH Public Key",id:"ssh-public-key",level:3},{value:"ssh_public_key_created.v0",id:"ssh_public_key_createdv0",level:4},{value:"ssh_public_key_deleted.v0",id:"ssh_public_key_deletedv0",level:4},{value:"ssh_public_key_updated.v0",id:"ssh_public_key_updatedv0",level:4},{value:"SSH User Certificate",id:"ssh-user-certificate",level:3},{value:"ssh_user_certificate_created.v0",id:"ssh_user_certificate_createdv0",level:4},{value:"ssh_user_certificate_deleted.v0",id:"ssh_user_certificate_deletedv0",level:4},{value:"ssh_user_certificate_updated.v0",id:"ssh_user_certificate_updatedv0",level:4},{value:"TCP Address",id:"tcp-address",level:3},{value:"tcp_address_created.v0",id:"tcp_address_createdv0",level:4},{value:"tcp_address_deleted.v0",id:"tcp_address_deletedv0",level:4},{value:"tcp_address_updated.v0",id:"tcp_address_updatedv0",level:4},{value:"TLS Certificate",id:"tls-certificate",level:3},{value:"tls_certificate_created.v0",id:"tls_certificate_createdv0",level:4},{value:"tls_certificate_deleted.v0",id:"tls_certificate_deletedv0",level:4},{value:"tls_certificate_updated.v0",id:"tls_certificate_updatedv0",level:4},{value:"Tunnel Credential",id:"tunnel-credential",level:3},{value:"tunnel_credential_created.v0",id:"tunnel_credential_createdv0",level:4},{value:"tunnel_credential_deleted.v0",id:"tunnel_credential_deletedv0",level:4},{value:"tunnel_credential_updated.v0",id:"tunnel_credential_updatedv0",level:4}],o={toc:m},s="wrapper";function u(t){let{components:e,...a}=t;return(0,r.kt)(s,(0,n.Z)({},o,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"event-source-reference"},"Event Source Reference"),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"event-sources"},"Event Sources"),(0,r.kt)("h4",{id:"traffic-events"},"Traffic Events"),(0,r.kt)("p",null,"Traffic Events fire when traffic transits through your endpoints like\nprocessing an HTTP request or TCP connection. Because Traffic Events are often\nhigh cardinality, they support the ability to select which fields to capture as\nwell as the ability to specify a ",(0,r.kt)("a",{parentName:"p",href:"/events#filters"},"CEL filter expression")," to\nlimit which events are captured."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Event"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#http_request_completev0"},(0,r.kt)("inlineCode",{parentName:"a"},"http_request_complete.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an HTTP request completes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tcp_connection_closedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tcp_connection_closed.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a TCP connection to an endpoint closes.")))),(0,r.kt)("h4",{id:"configuration-events"},"Configuration Events"),(0,r.kt)("p",null,"Configuration Events fire when you make changes to your account like creating,\nupdating or deleting objects like Domains, API Keys and IP Policies."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Event"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#api_key_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"api_key_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an API key is created")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#api_key_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"api_key_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an API key is deleted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#api_key_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"api_key_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an API key is updated")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#certificate_authority_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"certificate_authority_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a certificate authority is created")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#certificate_authority_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"certificate_authority_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a certificate authority is deleted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#certificate_authority_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"certificate_authority_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a certificate authority is updated")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#domain_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"domain_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a domain is created")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#domain_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"domain_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a domain is deleted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#domain_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"domain_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a domain is updated")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#event_destination_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"event_destination_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an Event Destination is created")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#event_destination_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"event_destination_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an Event Destination is deleted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#event_destination_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"event_destination_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an Event Destination is updated")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#event_subscription_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"event_subscription_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an Event Subscription is created")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#event_subscription_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"event_subscription_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an Event Subscription is deleted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#event_subscription_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"event_subscription_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an Event Subscription is updated")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_policy_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_policy_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Policy is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_policy_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_policy_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Policy is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_policy_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_policy_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Policy is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_policy_rule_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_policy_rule_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Policy Rule is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_policy_rule_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_policy_rule_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Policy Rule is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_policy_rule_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_policy_rule_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Policy Rule is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_restriction_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_restriction_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Restriction is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_restriction_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_restriction_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Restriction is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ip_restriction_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ip_restriction_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an IP Restriction is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_certificate_authority_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_certificate_authority_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH certificate authority is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_certificate_authority_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_certificate_authority_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH certificate authority is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_certificate_authority_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_certificate_authority_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH certificate authority is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_host_certificate_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_host_certificate_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH host certificate is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_host_certificate_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_host_certificate_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH host certificate is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_host_certificate_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_host_certificate_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH host certificate is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_public_key_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_public_key_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH public key is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_public_key_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_public_key_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH public key is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_public_key_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_public_key_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH public key is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_user_certificate_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_user_certificate_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH user certificate is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_user_certificate_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_user_certificate_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH user certificate is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ssh_user_certificate_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"ssh_user_certificate_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when an SSH user certificate is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tcp_address_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tcp_address_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a TCP address is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tcp_address_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tcp_address_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a TCP address is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tcp_address_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tcp_address_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a TCP address is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tls_certificate_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tls_certificate_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a TLS certificate is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tls_certificate_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tls_certificate_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a TLS certificate is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tls_certificate_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tls_certificate_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a TLS certificate is updated.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tunnel_credential_createdv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tunnel_credential_created.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a tunnel credential is created.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tunnel_credential_deletedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tunnel_credential_deleted.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a tunnel credential is deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#tunnel_credential_updatedv0"},(0,r.kt)("inlineCode",{parentName:"a"},"tunnel_credential_updated.v0"))),(0,r.kt)("td",{parentName:"tr",align:null},"Triggers when a tunnel credential is updated.")))),(0,r.kt)("h2",{id:"traffic-events-1"},"Traffic Events"),(0,r.kt)("h3",{id:"http-request-complete"},"HTTP Request Complete"),(0,r.kt)("h4",{id:"http_request_completev0"},"http_request_complete.v0"),(0,r.kt)("p",null,"Triggers when an HTTP request completes."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"backend.connection_reused"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"True if ngrok reused a TCP connection to transmit the HTTP request to the upstream service."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"basic_auth.decision"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2018allow\u2019 if the Basic Auth module permitted the request to the upstream service, otherwise \u2018block\u2019"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"basic_auth.username"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The username in the HTTP basic auth credentials"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"circuit_breaker.decision"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Whether the HTTP request was sent to the upstream service. \u2018allow\u2019 if the breaker was closed, \u2018block\u2019 if the breaker was open, \u2018allow_while_open\u2019 if the request was allowed while the breaker is open"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"compression.algorithm"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The compression algorithm used to encode responses from the endpoint. Either \u2018gzip\u2019, \u2018deflate\u2019, or \u2018none\u2019."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"compression.bytes_saved"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"The difference between the size of the raw response and the size of the response as compressed by the Compression Module"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.client_ip"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"filterable"),(0,r.kt)("td",{parentName:"tr",align:null},"The source IP of the TCP connection to the ngrok edge")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.server_ip"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"filterable"),(0,r.kt)("td",{parentName:"tr",align:null},"The IP address of the server that received the request")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.server_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"filterable"),(0,r.kt)("td",{parentName:"tr",align:null},"The hostname associated with this connection.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.server_port"),(0,r.kt)("td",{parentName:"tr",align:null},"int32"),(0,r.kt)("td",{parentName:"tr",align:null},"filterable"),(0,r.kt)("td",{parentName:"tr",align:null},"The port that the connection for this request came in on")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.start_ts"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp"),(0,r.kt)("td",{parentName:"tr",align:null},"The timestamp when the TCP connection to the ngrok edge is established"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.body_length"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"The size of the request body in bytes"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.headers"),(0,r.kt)("td",{parentName:"tr",align:null},"Map","<","string, List<string",">",">"),(0,r.kt)("td",{parentName:"tr",align:null},"A map of normalized headers from the requesting client. Header keys are capitalized and header values are lowercased."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.method"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The request method, normalized to lowercase"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.url.host"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The host component of the request URL"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.url.path"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The path component of the request URL"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.url.query"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The query string component of the request URL"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.url.raw"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The full URL of the request including scheme, host, path, and query string"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.url.scheme"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The scheme component of the request URL"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.request.user_agent"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The value of the User-Agent header in the request received by ngrok edge"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.response.body_length"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"The size of the response body in bytes"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.response.headers"),(0,r.kt)("td",{parentName:"tr",align:null},"Map","<","string, List<string",">",">"),(0,r.kt)("td",{parentName:"tr",align:null},"A map of normalized response headers. Header keys are capitalized and header values are lowercased."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"http.response.status_code"),(0,r.kt)("td",{parentName:"tr",align:null},"int32"),(0,r.kt)("td",{parentName:"tr",align:null},"The status code of the response returned by the ngrok edge"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policy.decision"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2018allow\u2019 if IP Policy module permitted the request to the upstream service, \u2018block\u2019 otherwise"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oauth.app_client_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The OAuth application client ID"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oauth.decision"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2018allow\u2019 if the OAuth module permitted the request to the upstream service, \u2018block\u2019 otherwise"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oauth.user.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The authenticated user\u2019s ID returned by the OAuth provider"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"oauth.user.name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The authenticated user\u2019s name returned by the OAuth provider"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tls.cipher_suite"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The cipher suite selected during the TLS handshake"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tls.client_cert.serial_number"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The serial number of the client\u2019s leaf TLS certificate in the Mutual TLS handshake"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tls.client_cert.subject.cn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The subject common name of the client\u2019s leaf TLS certificate in the Mutual TLS handshake"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tls.version"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The version of the TLS protocol used between the client and the ngrok edge"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"webhook_verification.decision"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2018allow\u2019 if the Webhook Verification module permitted the request to the upstream service, \u2018block\u2019 otherwise"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"tcp-connection-closed"},"TCP Connection Closed"),(0,r.kt)("h4",{id:"tcp_connection_closedv0"},"tcp_connection_closed.v0"),(0,r.kt)("p",null,"Triggers when a TCP connection to an endpoint closes."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.bytes_in"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of bytes arriving at an endpoint from the frontend"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.bytes_out"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of bytes leaving an endpoint to the frontend"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.client_ip"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"filterable"),(0,r.kt)("td",{parentName:"tr",align:null},"The source IP of the TCP connection to the ngrok edge")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.end_ts"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp"),(0,r.kt)("td",{parentName:"tr",align:null},"The timestamp when the TCP connection to the ngrok edge is closed"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.server_ip"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"filterable"),(0,r.kt)("td",{parentName:"tr",align:null},"The IP address of the server that received the request")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.server_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"filterable"),(0,r.kt)("td",{parentName:"tr",align:null},"The hostname associated with this connection.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.server_port"),(0,r.kt)("td",{parentName:"tr",align:null},"int32"),(0,r.kt)("td",{parentName:"tr",align:null},"filterable"),(0,r.kt)("td",{parentName:"tr",align:null},"The port that the connection for this request came in on")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"conn.start_ts"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp"),(0,r.kt)("td",{parentName:"tr",align:null},"The timestamp when the TCP connection to the ngrok edge is established"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policy.decision"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2018allow\u2019 if IP Policy module permitted the request to the upstream service, \u2018block\u2019 otherwise"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h2",{id:"configuration-events-1"},"Configuration Events"),(0,r.kt)("h3",{id:"api-key"},"API Key"),(0,r.kt)("h4",{id:"api_key_createdv0"},"api_key_created.v0"),(0,r.kt)("p",null,"Triggers when an API key is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique API key resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI to the API resource of this API key")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what uses the API key to authenticate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined data of this API key. optional, max 4096 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the api key was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"token"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the bearer token that can be placed into the Authorization header to authenticate request to the ngrok API. ",(0,r.kt)("strong",{parentName:"td"},"This value is only available one time, on the API response from key creation. Otherwise it is null."))))),(0,r.kt)("h4",{id:"api_key_deletedv0"},"api_key_deleted.v0"),(0,r.kt)("p",null,"Triggers when an API key is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique API key resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI to the API resource of this API key")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what uses the API key to authenticate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined data of this API key. optional, max 4096 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the api key was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"token"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the bearer token that can be placed into the Authorization header to authenticate request to the ngrok API. ",(0,r.kt)("strong",{parentName:"td"},"This value is only available one time, on the API response from key creation. Otherwise it is null."))))),(0,r.kt)("h4",{id:"api_key_updatedv0"},"api_key_updated.v0"),(0,r.kt)("p",null,"Triggers when an API key is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique API key resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI to the API resource of this API key")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what uses the API key to authenticate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined data of this API key. optional, max 4096 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the api key was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"token"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the bearer token that can be placed into the Authorization header to authenticate request to the ngrok API. ",(0,r.kt)("strong",{parentName:"td"},"This value is only available one time, on the API response from key creation. Otherwise it is null."))))),(0,r.kt)("h3",{id:"certificate-authority"},"Certificate Authority"),(0,r.kt)("h4",{id:"certificate_authority_createdv0"},"certificate_authority_created.v0"),(0,r.kt)("p",null,"Triggers when a certificate authority is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Certificate Authority API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the Certificate Authority was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this Certificate Authority. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ca_pem"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"raw PEM of the Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject common name of the Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_before"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this Certificate Authority becomes valid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this Certificate Authority becomes invalid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of actions the private key of this Certificate Authority can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extended_key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"extended set of actions the private key of this Certificate Authority can be used for")))),(0,r.kt)("h4",{id:"certificate_authority_deletedv0"},"certificate_authority_deleted.v0"),(0,r.kt)("p",null,"Triggers when a certificate authority is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Certificate Authority API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the Certificate Authority was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this Certificate Authority. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ca_pem"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"raw PEM of the Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject common name of the Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_before"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this Certificate Authority becomes valid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this Certificate Authority becomes invalid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of actions the private key of this Certificate Authority can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extended_key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"extended set of actions the private key of this Certificate Authority can be used for")))),(0,r.kt)("h4",{id:"certificate_authority_updatedv0"},"certificate_authority_updated.v0"),(0,r.kt)("p",null,"Triggers when a certificate authority is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Certificate Authority API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the Certificate Authority was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this Certificate Authority. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ca_pem"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"raw PEM of the Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject common name of the Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_before"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this Certificate Authority becomes valid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this Certificate Authority becomes invalid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of actions the private key of this Certificate Authority can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extended_key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"extended set of actions the private key of this Certificate Authority can be used for")))),(0,r.kt)("h3",{id:"domain"},"Domain"),(0,r.kt)("h4",{id:"domain_createdv0"},"domain_created.v0"),(0,r.kt)("p",null,"Triggers when a domain is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique reserved domain resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the reserved domain API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the reserved domain was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what this reserved domain will be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"domain"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"hostname of the reserved domain")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"region"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"reserve the domain in this geographic ngrok region. Optional, default is us. (au, eu, ap, us, jp, in, sa)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cname_target"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of an ngrok domain")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_policy.authority"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"certificate authority to request certificates from. The only supported value is letsencrypt.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_policy.private_key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.renews_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the next renewal will be requested, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.error_code"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"if present, an error code indicating why provisioning is failing. It may be either a temporary condition (INTERNAL_ERROR), or a permanent one the user must correct (DNS_ERROR).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.msg"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a message describing the current status or error")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.started_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the provisioning job started, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.retries_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the provisioning job will be retried")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acme_challenge_cname_target"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"DNS CNAME target for the host ","_","acme-challenge.example.com, where example.com is your reserved domain name. This is required to issue certificates for wildcard, non-ngrok reserved domains. Must be null for non-wildcard domains and ngrok subdomains.")))),(0,r.kt)("h4",{id:"domain_deletedv0"},"domain_deleted.v0"),(0,r.kt)("p",null,"Triggers when a domain is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique reserved domain resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the reserved domain API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the reserved domain was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what this reserved domain will be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"domain"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"hostname of the reserved domain")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"region"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"reserve the domain in this geographic ngrok region. Optional, default is us. (au, eu, ap, us, jp, in, sa)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cname_target"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of ","*",".ngrok.io")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_policy.authority"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"certificate authority to request certificates from. The only supported value is letsencrypt.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_policy.private_key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.renews_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the next renewal will be requested, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.error_code"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"if present, an error code indicating why provisioning is failing. It may be either a temporary condition (INTERNAL_ERROR), or a permanent one the user must correct (DNS_ERROR).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.msg"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a message describing the current status or error")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.started_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the provisioning job started, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.retries_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the provisioning job will be retried")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acme_challenge_cname_target"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"DNS CNAME target for the host ","_","acme-challenge.example.com, where example.com is your reserved domain name. This is required to issue certificates for wildcard, non-ngrok reserved domains. Must be null for non-wildcard domains and ngrok subdomains.")))),(0,r.kt)("h4",{id:"domain_updatedv0"},"domain_updated.v0"),(0,r.kt)("p",null,"Triggers when a domain is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique reserved domain resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the reserved domain API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the reserved domain was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what this reserved domain will be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"domain"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"hostname of the reserved domain")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"region"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"reserve the domain in this geographic ngrok region. Optional, default is us. (au, eu, ap, us, jp, in, sa)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cname_target"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of ","*",".ngrok.io")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_policy.authority"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"certificate authority to request certificates from. The only supported value is letsencrypt.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_policy.private_key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.renews_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the next renewal will be requested, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.error_code"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"if present, an error code indicating why provisioning is failing. It may be either a temporary condition (INTERNAL_ERROR), or a permanent one the user must correct (DNS_ERROR).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.msg"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a message describing the current status or error")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.started_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the provisioning job started, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_management_status.provisioning_job.retries_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the provisioning job will be retried")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acme_challenge_cname_target"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"DNS CNAME target for the host ","_","acme-challenge.example.com, where example.com is your reserved domain name. This is required to issue certificates for wildcard, non-ngrok reserved domains. Must be null for non-wildcard domains and ngrok subdomains.")))),(0,r.kt)("h3",{id:"event-destination"},"Event Destination"),(0,r.kt)("h4",{id:"event_destination_createdv0"},"event_destination_created.v0"),(0,r.kt)("p",null,"Triggers when an Event Destination is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Unique identifier for this Event Destination.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Timestamp when the Event Destination was created, RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Human-readable description of the Event Destination. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"format"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The output format you would like to serialize events into when sending to their target. Currently the only accepted value is ",(0,r.kt)("inlineCode",{parentName:"td"},"JSON"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.delivery_stream_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.stream_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the Kinesis stream to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.log_group_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Destination API resource.")))),(0,r.kt)("h4",{id:"event_destination_deletedv0"},"event_destination_deleted.v0"),(0,r.kt)("p",null,"Triggers when an Event Destination is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Unique identifier for this Event Destination.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Timestamp when the Event Destination was created, RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Human-readable description of the Event Destination. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"format"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The output format you would like to serialize events into when sending to their target. Currently the only accepted value is ",(0,r.kt)("inlineCode",{parentName:"td"},"JSON"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.delivery_stream_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.stream_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the Kinesis stream to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.log_group_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Destination API resource.")))),(0,r.kt)("h4",{id:"event_destination_updatedv0"},"event_destination_updated.v0"),(0,r.kt)("p",null,"Triggers when an Event Destination is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Unique identifier for this Event Destination.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Timestamp when the Event Destination was created, RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Human-readable description of the Event Destination. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"format"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The output format you would like to serialize events into when sending to their target. Currently the only accepted value is ",(0,r.kt)("inlineCode",{parentName:"td"},"JSON"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.firehose.delivery_stream_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.kinesis.stream_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the Kinesis stream to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.role.role_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An ARN that specifies the role that ngrok should use to deliver to the configured target.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.creds.aws_access_key_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The ID portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.auth.creds.aws_secret_access_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The secret portion of an AWS access key.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"target.cloudwatch_logs.log_group_arn"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Destination API resource.")))),(0,r.kt)("h3",{id:"event-subscription"},"Event Subscription"),(0,r.kt)("h4",{id:"event_subscription_createdv0"},"event_subscription_created.v0"),(0,r.kt)("p",null,"Triggers when an Event Subscription is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Unique identifier for this Event Subscription.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Subscription API resource.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"When the Event Subscription was created (RFC 3339 format).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sources.type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Type of event for which an event subscription will trigger")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sources.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Source API resource.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"destinations.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"destinations.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")))),(0,r.kt)("h4",{id:"event_subscription_deletedv0"},"event_subscription_deleted.v0"),(0,r.kt)("p",null,"Triggers when an Event Subscription is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Unique identifier for this Event Subscription.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Subscription API resource.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"When the Event Subscription was created (RFC 3339 format).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sources.type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Type of event for which an event subscription will trigger")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sources.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Source API resource.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"destinations.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"destinations.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")))),(0,r.kt)("h4",{id:"event_subscription_updatedv0"},"event_subscription_updated.v0"),(0,r.kt)("p",null,"Triggers when an Event Subscription is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Unique identifier for this Event Subscription.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Subscription API resource.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"When the Event Subscription was created (RFC 3339 format).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sources.type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Type of event for which an event subscription will trigger")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sources.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the Event Source API resource.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"destinations.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"destinations.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")))),(0,r.kt)("h3",{id:"ip-policy"},"IP Policy"),(0,r.kt)("h4",{id:"ip_policy_createdv0"},"ip_policy_created.v0"),(0,r.kt)("p",null,"Triggers when an IP Policy is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP policy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP Policy API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP policy was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of the source IPs of this IP policy. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.")))),(0,r.kt)("h4",{id:"ip_policy_updatedv0"},"ip_policy_updated.v0"),(0,r.kt)("p",null,"Triggers when an IP Policy is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP policy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP Policy API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP policy was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of the source IPs of this IP policy. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.")))),(0,r.kt)("h4",{id:"ip_policy_deletedv0"},"ip_policy_deleted.v0"),(0,r.kt)("p",null,"Triggers when an IP Policy is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP policy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP Policy API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP policy was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of the source IPs of this IP policy. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.")))),(0,r.kt)("h3",{id:"ip-policy-rule"},"IP Policy Rule"),(0,r.kt)("h4",{id:"ip_policy_rule_createdv0"},"ip_policy_rule_created.v0"),(0,r.kt)("p",null,"Triggers when an IP Policy Rule is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP policy rule")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP policy rule API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP policy rule was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of the source IPs of this IP rule. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cidr"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policy.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policy.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"action"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the action to apply to the policy rule, either ",(0,r.kt)("inlineCode",{parentName:"td"},"allow")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"deny"))))),(0,r.kt)("h4",{id:"ip_policy_rule_deletedv0"},"ip_policy_rule_deleted.v0"),(0,r.kt)("p",null,"Triggers when an IP Policy Rule is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP policy rule")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP policy rule API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP policy rule was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of the source IPs of this IP rule. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cidr"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policy.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policy.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"action"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the action to apply to the policy rule, either ",(0,r.kt)("inlineCode",{parentName:"td"},"allow")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"deny"))))),(0,r.kt)("h4",{id:"ip_policy_rule_updatedv0"},"ip_policy_rule_updated.v0"),(0,r.kt)("p",null,"Triggers when an IP Policy Rule is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP policy rule")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP policy rule API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP policy rule was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of the source IPs of this IP rule. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cidr"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policy.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policy.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"action"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the action to apply to the policy rule, either ",(0,r.kt)("inlineCode",{parentName:"td"},"allow")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"deny"))))),(0,r.kt)("h3",{id:"ip-restriction"},"IP Restriction"),(0,r.kt)("h4",{id:"ip_restriction_createdv0"},"ip_restriction_created.v0"),(0,r.kt)("p",null,"Triggers when an IP Restriction is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP restriction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP restriction API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP restriction was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this IP restriction. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enforced"),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},"true if the IP restriction will be enforced. if false, only warnings will be issued")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: ",(0,r.kt)("inlineCode",{parentName:"td"},"dashboard"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"api"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"agent"),", and ",(0,r.kt)("inlineCode",{parentName:"td"},"endpoints"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policies.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policies.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")))),(0,r.kt)("h4",{id:"ip_restriction_deletedv0"},"ip_restriction_deleted.v0"),(0,r.kt)("p",null,"Triggers when an IP Restriction is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP restriction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP restriction API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP restriction was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this IP restriction. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enforced"),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},"true if the IP restriction will be enforced. if false, only warnings will be issued")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: ",(0,r.kt)("inlineCode",{parentName:"td"},"dashboard"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"api"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"agent"),", and ",(0,r.kt)("inlineCode",{parentName:"td"},"endpoints"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policies.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policies.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")))),(0,r.kt)("h4",{id:"ip_restriction_updatedv0"},"ip_restriction_updated.v0"),(0,r.kt)("p",null,"Triggers when an IP Restriction is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this IP restriction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the IP restriction API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the IP restriction was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this IP restriction. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"enforced"),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},"true if the IP restriction will be enforced. if false, only warnings will be issued")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: ",(0,r.kt)("inlineCode",{parentName:"td"},"dashboard"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"api"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"agent"),", and ",(0,r.kt)("inlineCode",{parentName:"td"},"endpoints"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policies.id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ip_policies.uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a uri for locating a resource")))),(0,r.kt)("h3",{id:"ssh-certificate-authority"},"SSH Certificate Authority"),(0,r.kt)("h4",{id:"ssh_certificate_authority_createdv0"},"ssh_certificate_authority_created.v0"),(0,r.kt)("p",null,"Triggers when an SSH certificate authority is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH Certificate Authority API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH Certificate Authority API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH Certificate Authority. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"raw public key for this SSH Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the type of private key for this SSH Certificate Authority")))),(0,r.kt)("h4",{id:"ssh_certificate_authority_deletedv0"},"ssh_certificate_authority_deleted.v0"),(0,r.kt)("p",null,"Triggers when an SSH certificate authority is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH Certificate Authority API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH Certificate Authority API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH Certificate Authority. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"raw public key for this SSH Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the type of private key for this SSH Certificate Authority")))),(0,r.kt)("h4",{id:"ssh_certificate_authority_updatedv0"},"ssh_certificate_authority_updated.v0"),(0,r.kt)("p",null,"Triggers when an SSH certificate authority is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH Certificate Authority API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH Certificate Authority API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH Certificate Authority. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"raw public key for this SSH Certificate Authority")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the type of private key for this SSH Certificate Authority")))),(0,r.kt)("h3",{id:"ssh-host-certificate"},"SSH Host Certificate"),(0,r.kt)("h4",{id:"ssh_host_certificate_createdv0"},"ssh_host_certificate_created.v0"),(0,r.kt)("p",null,"Triggers when an SSH host certificate is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH Host Certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH Host Certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH Host Certificate API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH Host Certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a public key in OpenSSH Authorized Keys format that this certificate signs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the key type of the ",(0,r.kt)("inlineCode",{parentName:"td"},"public_key"),", one of ",(0,r.kt)("inlineCode",{parentName:"td"},"rsa"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ecdsa")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"ed25519"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ssh_certificate_authority_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the ssh certificate authority that is used to sign this ssh host certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"principals"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time when the ssh host certificate becomes valid, in RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_until"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this ",(0,r.kt)("inlineCode",{parentName:"td"},"valid_before"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the signed SSH certificate in OpenSSH Authorized Keys format. this value should be placed in a ",(0,r.kt)("inlineCode",{parentName:"td"},"-cert.pub")," certificate file on disk that should be referenced in your ",(0,r.kt)("inlineCode",{parentName:"td"},"sshd_config")," configuration file with a ",(0,r.kt)("inlineCode",{parentName:"td"},"HostCertificate")," directive")))),(0,r.kt)("h4",{id:"ssh_host_certificate_deletedv0"},"ssh_host_certificate_deleted.v0"),(0,r.kt)("p",null,"Triggers when an SSH host certificate is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH Host Certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH Host Certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH Host Certificate API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH Host Certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a public key in OpenSSH Authorized Keys format that this certificate signs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the key type of the ",(0,r.kt)("inlineCode",{parentName:"td"},"public_key"),", one of ",(0,r.kt)("inlineCode",{parentName:"td"},"rsa"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ecdsa")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"ed25519"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ssh_certificate_authority_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the ssh certificate authority that is used to sign this ssh host certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"principals"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time when the ssh host certificate becomes valid, in RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_until"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this ",(0,r.kt)("inlineCode",{parentName:"td"},"valid_before"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the signed SSH certificate in OpenSSH Authorized Keys format. this value should be placed in a ",(0,r.kt)("inlineCode",{parentName:"td"},"-cert.pub")," certificate file on disk that should be referenced in your ",(0,r.kt)("inlineCode",{parentName:"td"},"sshd_config")," configuration file with a ",(0,r.kt)("inlineCode",{parentName:"td"},"HostCertificate")," directive")))),(0,r.kt)("h4",{id:"ssh_host_certificate_updatedv0"},"ssh_host_certificate_updated.v0"),(0,r.kt)("p",null,"Triggers when an SSH host certificate is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH Host Certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH Host Certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH Host Certificate API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH Host Certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a public key in OpenSSH Authorized Keys format that this certificate signs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the key type of the ",(0,r.kt)("inlineCode",{parentName:"td"},"public_key"),", one of ",(0,r.kt)("inlineCode",{parentName:"td"},"rsa"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ecdsa")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"ed25519"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ssh_certificate_authority_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the ssh certificate authority that is used to sign this ssh host certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"principals"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time when the ssh host certificate becomes valid, in RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_until"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this ",(0,r.kt)("inlineCode",{parentName:"td"},"valid_before"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the signed SSH certificate in OpenSSH Authorized Keys format. this value should be placed in a ",(0,r.kt)("inlineCode",{parentName:"td"},"-cert.pub")," certificate file on disk that should be referenced in your ",(0,r.kt)("inlineCode",{parentName:"td"},"sshd_config")," configuration file with a ",(0,r.kt)("inlineCode",{parentName:"td"},"HostCertificate")," directive")))),(0,r.kt)("h3",{id:"ssh-public-key"},"SSH Public Key"),(0,r.kt)("h4",{id:"ssh_public_key_createdv0"},"ssh_public_key_created.v0"),(0,r.kt)("p",null,"Triggers when an SSH public key is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique ssh credential resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the ssh credential API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the ssh credential was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the PEM-encoded public key of the SSH keypair that will be used to authenticate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acl"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule. The ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:example.ngrok.io"),". Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:*.example.com")," which will allow ",(0,r.kt)("inlineCode",{parentName:"td"},"x.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"y.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*.example.com"),", etc. A rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"'*'")," is equivalent to no acl at all and will explicitly permit all actions.")))),(0,r.kt)("h4",{id:"ssh_public_key_deletedv0"},"ssh_public_key_deleted.v0"),(0,r.kt)("p",null,"Triggers when an SSH public key is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique ssh credential resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the ssh credential API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the ssh credential was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the PEM-encoded public key of the SSH keypair that will be used to authenticate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acl"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule. The ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:example.ngrok.io"),". Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:*.example.com")," which will allow ",(0,r.kt)("inlineCode",{parentName:"td"},"x.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"y.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*.example.com"),", etc. A rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"'*'")," is equivalent to no acl at all and will explicitly permit all actions.")))),(0,r.kt)("h4",{id:"ssh_public_key_updatedv0"},"ssh_public_key_updated.v0"),(0,r.kt)("p",null,"Triggers when an SSH public key is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique ssh credential resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the ssh credential API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the ssh credential was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the PEM-encoded public key of the SSH keypair that will be used to authenticate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acl"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule. The ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:example.ngrok.io"),". Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:*.example.com")," which will allow ",(0,r.kt)("inlineCode",{parentName:"td"},"x.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"y.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*.example.com"),", etc. A rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"'*'")," is equivalent to no acl at all and will explicitly permit all actions.")))),(0,r.kt)("h3",{id:"ssh-user-certificate"},"SSH User Certificate"),(0,r.kt)("h4",{id:"ssh_user_certificate_createdv0"},"ssh_user_certificate_created.v0"),(0,r.kt)("p",null,"Triggers when an SSH user certificate is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH User Certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH User Certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH User Certificate API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH User Certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a public key in OpenSSH Authorized Keys format that this certificate signs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the key type of the ",(0,r.kt)("inlineCode",{parentName:"td"},"public_key"),", one of ",(0,r.kt)("inlineCode",{parentName:"td"},"rsa"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ecdsa")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"ed25519"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ssh_certificate_authority_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the ssh certificate authority that is used to sign this ssh user certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"principals"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"critical_options"),(0,r.kt)("td",{parentName:"tr",align:null},"Map","<","string, string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: ",(0,r.kt)("inlineCode",{parentName:"td"},"force-command")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"source-address"),". See ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys"},"the OpenSSH certificate protocol spec")," for additional details.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extensions"),(0,r.kt)("td",{parentName:"tr",align:null},"Map","<","string, string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: ",(0,r.kt)("inlineCode",{parentName:"td"},'{"permit-pty": "", "permit-user-rc": ""}')," OpenSSH understands a number of predefined extensions. See ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys"},"the OpenSSH certificate protocol spec")," for additional details.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time when the ssh host certificate becomes valid, in RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_until"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this ",(0,r.kt)("inlineCode",{parentName:"td"},"valid_before"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a ",(0,r.kt)("inlineCode",{parentName:"td"},"-cert.pub")," certificate file on disk that should be referenced in your ",(0,r.kt)("inlineCode",{parentName:"td"},"sshd_config")," configuration file with a ",(0,r.kt)("inlineCode",{parentName:"td"},"HostCertificate")," directive")))),(0,r.kt)("h4",{id:"ssh_user_certificate_deletedv0"},"ssh_user_certificate_deleted.v0"),(0,r.kt)("p",null,"Triggers when an SSH user certificate is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH User Certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH User Certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH User Certificate API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH User Certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a public key in OpenSSH Authorized Keys format that this certificate signs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the key type of the ",(0,r.kt)("inlineCode",{parentName:"td"},"public_key"),", one of ",(0,r.kt)("inlineCode",{parentName:"td"},"rsa"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ecdsa")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"ed25519"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ssh_certificate_authority_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the ssh certificate authority that is used to sign this ssh user certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"principals"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"critical_options"),(0,r.kt)("td",{parentName:"tr",align:null},"Map","<","string, string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: ",(0,r.kt)("inlineCode",{parentName:"td"},"force-command")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"source-address"),". See ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys"},"the OpenSSH certificate protocol spec")," for additional details.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extensions"),(0,r.kt)("td",{parentName:"tr",align:null},"Map","<","string, string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: ",(0,r.kt)("inlineCode",{parentName:"td"},'{"permit-pty": "", "permit-user-rc": ""}')," OpenSSH understands a number of predefined extensions. See ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys"},"the OpenSSH certificate protocol spec")," for additional details.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time when the ssh host certificate becomes valid, in RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_until"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this ",(0,r.kt)("inlineCode",{parentName:"td"},"valid_before"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a ",(0,r.kt)("inlineCode",{parentName:"td"},"-cert.pub")," certificate file on disk that should be referenced in your ",(0,r.kt)("inlineCode",{parentName:"td"},"sshd_config")," configuration file with a ",(0,r.kt)("inlineCode",{parentName:"td"},"HostCertificate")," directive")))),(0,r.kt)("h4",{id:"ssh_user_certificate_updatedv0"},"ssh_user_certificate_updated.v0"),(0,r.kt)("p",null,"Triggers when an SSH user certificate is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this SSH User Certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the SSH User Certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the SSH User Certificate API resource was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this SSH User Certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"public_key"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"a public key in OpenSSH Authorized Keys format that this certificate signs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the key type of the ",(0,r.kt)("inlineCode",{parentName:"td"},"public_key"),", one of ",(0,r.kt)("inlineCode",{parentName:"td"},"rsa"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ecdsa")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"ed25519"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ssh_certificate_authority_id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the ssh certificate authority that is used to sign this ssh user certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"principals"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"critical_options"),(0,r.kt)("td",{parentName:"tr",align:null},"Map","<","string, string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: ",(0,r.kt)("inlineCode",{parentName:"td"},"force-command")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"source-address"),". See ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys"},"the OpenSSH certificate protocol spec")," for additional details.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extensions"),(0,r.kt)("td",{parentName:"tr",align:null},"Map","<","string, string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: ",(0,r.kt)("inlineCode",{parentName:"td"},'{"permit-pty": "", "permit-user-rc": ""}')," OpenSSH understands a number of predefined extensions. See ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys"},"the OpenSSH certificate protocol spec")," for additional details.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time when the ssh host certificate becomes valid, in RFC 3339 format.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_until"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this ",(0,r.kt)("inlineCode",{parentName:"td"},"valid_before"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a ",(0,r.kt)("inlineCode",{parentName:"td"},"-cert.pub")," certificate file on disk that should be referenced in your ",(0,r.kt)("inlineCode",{parentName:"td"},"sshd_config")," configuration file with a ",(0,r.kt)("inlineCode",{parentName:"td"},"HostCertificate")," directive")))),(0,r.kt)("h3",{id:"tcp-address"},"TCP Address"),(0,r.kt)("h4",{id:"tcp_address_createdv0"},"tcp_address_created.v0"),(0,r.kt)("p",null,"Triggers when a TCP address is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique reserved address resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the reserved address API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the reserved address was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what this reserved address will be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"addr"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"hostname:port of the reserved address that was assigned at creation time")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"region"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"reserve the address in this geographic ngrok region. Optional, default is us. (au, eu, ap, us, jp, in, sa)")))),(0,r.kt)("h4",{id:"tcp_address_deletedv0"},"tcp_address_deleted.v0"),(0,r.kt)("p",null,"Triggers when a TCP address is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique reserved address resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the reserved address API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the reserved address was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what this reserved address will be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"addr"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"hostname:port of the reserved address that was assigned at creation time")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"region"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"reserve the address in this geographic ngrok region. Optional, default is us. (au, eu, ap, us, jp, in, sa)")))),(0,r.kt)("h4",{id:"tcp_address_updatedv0"},"tcp_address_updated.v0"),(0,r.kt)("p",null,"Triggers when a TCP address is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique reserved address resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the reserved address API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the reserved address was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of what this reserved address will be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"addr"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"hostname:port of the reserved address that was assigned at creation time")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"region"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"reserve the address in this geographic ngrok region. Optional, default is us. (au, eu, ap, us, jp, in, sa)")))),(0,r.kt)("h3",{id:"tls-certificate"},"TLS Certificate"),(0,r.kt)("h4",{id:"tls_certificate_createdv0"},"tls_certificate_created.v0"),(0,r.kt)("p",null,"Triggers when a TLS certificate is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the TLS certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the TLS certificate was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this TLS certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_pem"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"chain of PEM-encoded certificates, leaf first. See ",(0,r.kt)("a",{parentName:"td",href:"/cloud-edge/endpoints#certificate-chains"},"Certificate Bundles"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject common name from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_alternative_names.dns_names"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of additional domains (including wildcards) this TLS certificate is valid for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_alternative_names.ips"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of IP addresses this TLS certificate is also valid for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"issued_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp (in RFC 3339 format) when this TLS certificate was issued automatically, or null if this certificate was user-uploaded")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_before"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this TLS certificate becomes valid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this TLS certificate becomes invalid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of actions the private key of this TLS certificate can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extended_key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"extended set of actions the private key of this TLS certificate can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"private_key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"type of the private key of this TLS certificate. One of rsa, ecdsa, or ed25519.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"issuer_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"issuer common name from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"serial_number"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"serial number of the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_organization"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject organization from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_organizational_unit"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject organizational unit from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_locality"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject locality from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_province"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject province from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_country"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject country from the leaf of this TLS certificate")))),(0,r.kt)("h4",{id:"tls_certificate_deletedv0"},"tls_certificate_deleted.v0"),(0,r.kt)("p",null,"Triggers when a TLS certificate is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the TLS certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the TLS certificate was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this TLS certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_pem"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"chain of PEM-encoded certificates, leaf first. See ",(0,r.kt)("a",{parentName:"td",href:"/cloud-edge/endpoints#certificate-chains"},"Certificate Bundles"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject common name from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_alternative_names.dns_names"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of additional domains (including wildcards) this TLS certificate is valid for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_alternative_names.ips"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of IP addresses this TLS certificate is also valid for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"issued_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp (in RFC 3339 format) when this TLS certificate was issued automatically, or null if this certificate was user-uploaded")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_before"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this TLS certificate becomes valid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this TLS certificate becomes invalid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of actions the private key of this TLS certificate can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extended_key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"extended set of actions the private key of this TLS certificate can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"private_key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"type of the private key of this TLS certificate. One of rsa, ecdsa, or ed25519.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"issuer_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"issuer common name from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"serial_number"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"serial number of the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_organization"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject organization from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_organizational_unit"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject organizational unit from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_locality"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject locality from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_province"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject province from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_country"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject country from the leaf of this TLS certificate")))),(0,r.kt)("h4",{id:"tls_certificate_updatedv0"},"tls_certificate_updated.v0"),(0,r.kt)("p",null,"Triggers when a TLS certificate is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique identifier for this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the TLS certificate API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the TLS certificate was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of this TLS certificate. optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"certificate_pem"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"chain of PEM-encoded certificates, leaf first. See ",(0,r.kt)("a",{parentName:"td",href:"/cloud-edge/endpoints#certificate-chains"},"Certificate Bundles"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject common name from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_alternative_names.dns_names"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of additional domains (including wildcards) this TLS certificate is valid for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_alternative_names.ips"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of IP addresses this TLS certificate is also valid for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"issued_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp (in RFC 3339 format) when this TLS certificate was issued automatically, or null if this certificate was user-uploaded")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_before"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this TLS certificate becomes valid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"not_after"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when this TLS certificate becomes invalid, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"set of actions the private key of this TLS certificate can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"extended_key_usages"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"extended set of actions the private key of this TLS certificate can be used for")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"private_key_type"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"type of the private key of this TLS certificate. One of rsa, ecdsa, or ed25519.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"issuer_common_name"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"issuer common name from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"serial_number"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"serial number of the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_organization"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject organization from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_organizational_unit"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject organizational unit from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_locality"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject locality from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_province"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject province from the leaf of this TLS certificate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subject_country"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"subject country from the leaf of this TLS certificate")))),(0,r.kt)("h3",{id:"tunnel-credential"},"Tunnel Credential"),(0,r.kt)("h4",{id:"tunnel_credential_createdv0"},"tunnel_credential_created.v0"),(0,r.kt)("p",null,"Triggers when a tunnel credential is created"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique tunnel credential resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the tunnel credential API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the tunnel credential was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"token"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the credential\u2019s authtoken that can be used to authenticate an ngrok agent. ",(0,r.kt)("strong",{parentName:"td"},"This value is only available one time, on the API response from credential creation, otherwise it is null."))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acl"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule. The ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:example.ngrok.io"),". Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:*.example.com")," which will allow ",(0,r.kt)("inlineCode",{parentName:"td"},"x.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"y.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*.example.com"),", etc. A rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"'*'")," is equivalent to no acl at all and will explicitly permit all actions.")))),(0,r.kt)("h4",{id:"tunnel_credential_deletedv0"},"tunnel_credential_deleted.v0"),(0,r.kt)("p",null,"Triggers when a tunnel credential is deleted"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique tunnel credential resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the tunnel credential API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the tunnel credential was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"token"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the credential\u2019s authtoken that can be used to authenticate an ngrok agent. ",(0,r.kt)("strong",{parentName:"td"},"This value is only available one time, on the API response from credential creation, otherwise it is null."))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acl"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule. The ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:example.ngrok.io"),". Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:*.example.com")," which will allow ",(0,r.kt)("inlineCode",{parentName:"td"},"x.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"y.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*.example.com"),", etc. A rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"'*'")," is equivalent to no acl at all and will explicitly permit all actions.")))),(0,r.kt)("h4",{id:"tunnel_credential_updatedv0"},"tunnel_credential_updated.v0"),(0,r.kt)("p",null,"Triggers when a tunnel credential is updated"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"id"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"unique tunnel credential resource identifier")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uri"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of the tunnel credential API resource")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"created_at"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the tunnel credential was created, RFC 3339 format")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"description"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"token"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"the credential\u2019s authtoken that can be used to authenticate an ngrok agent. ",(0,r.kt)("strong",{parentName:"td"},"This value is only available one time, on the API response from credential creation, otherwise it is null."))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"acl"),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","string",">"),(0,r.kt)("td",{parentName:"tr",align:null},"optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule. The ",(0,r.kt)("inlineCode",{parentName:"td"},"bind")," rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:example.ngrok.io"),". Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"bind:*.example.com")," which will allow ",(0,r.kt)("inlineCode",{parentName:"td"},"x.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"y.example.com"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*.example.com"),", etc. A rule of ",(0,r.kt)("inlineCode",{parentName:"td"},"'*'")," is equivalent to no acl at all and will explicitly permit all actions.")))))}u.isMDXComponent=!0}}]);