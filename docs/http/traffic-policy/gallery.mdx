---
title: Rule Gallery
pagination_label: Rule Gallery
---

import ConfigExample from "/src/components/ConfigExample.tsx";

# Rule Gallery

Explore a curated collection of example configurations spanning from common to unconventional use-cases for the Traffic Policy module.

## Deny non-GET requests:

This rule denies all inbound traffic that is not a GET request.

<ConfigExample
	config={{
		inbound: [
			{
				expressions: ["req.Method != 'GET'"],
				actions: [{ type: "deny" }],
			},
		],
	}}
/>

## Custom response for unauthorized requests

This rule sends a custom response with status code `401` and body `Unauthorized` for requests without an Authorization header.

<ConfigExample
	config={{
		inbound: [
			{
				expressions: ["!('Authorization' in req.Headers)"],
				actions: [
					{
						type: "custom-response",
						config: {
							status_code: 401,
							content: "Unauthorized",
						},
					},
				],
			},
		],
	}}
/>

## Rate limiting for specific endpoint:

This rule applies rate limiting of `30` requests per second to the endpoint `/api/videos`.

<ConfigExample
	config={{
		inbound: [
			{
				expressions: ["req.URL.contains('/api/specific_endpoint')"],
				actions: [
					{
						type: "rate-limit",
						config: {
							name: "Only allow 30 requests per minute",
							algorithm: "sliding_window",
							capacity: 30,
							rate: "60s",
							bucket_key: ["conn.ClientIP"],
						},
					},
				],
			},
		],
	}}
/>

## Enforce Basic Auth

This rule mimics the behavior of the [Basic Auth module](/http/basic-auth/). Requests that are missing the Authorization header or contain an invalid authorization value will receive an unauthorized response, prompting the requester to authorize themselves.

<ConfigExample
	config={{
		inbound: [
			{
				expressions: [
					"!('Authorization' in req.Headers) || !('Basic dXNlcm5hbWU6cGFzc3dvcmQ=' in req.Headers['Authorization'] || 'Basic dXNlcm5hbWU6aHVudGVyMg==' in req.Headers['Authorization'] || 'Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==' in req.Headers['Authorization'])",
				],
				actions: [
					{
						type: "custom-response",
						config: {
							status_code: 401,
							content: "Authorization required.",
							headers: {
								"WWW-Authenticate": 'Basic realm="MySite", charset="UTF-8"',
							},
						},
					},
				],
			},
			{
				actions: [
					{
						type: "custom-response",
						config: {
							status_code: 200,
							content: "Hello World",
						},
					},
				],
			},
		],
	}}
/>

Authorization header values are Base64 encoded `username:password` combos. Accepted combinations are:

- `username:password`
- `username:hunter2`
- `Aladdin:open sesame`

Doing basic auth enforcement this way has some benefits and drawbacks:

- You can choose the status code and content that ngrok responds with.
- You can declare the accepted authentication charset.
- You can enforce your own authentication realm.
- This will store passwords in plaintext on our system, and you should only do this if you understand the security implications of doing this.